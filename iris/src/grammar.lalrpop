use crate::ast::{Declaration, Definition, Type, Pattern, Rule, Expr, Literal, Extern, Let, Body, Guard};
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = ();

    enum Token {
        "const" => Token::Const,
        "constructor" => Token::Constructor,
        "decl" => Token::Decl,
        "extern" => Token::Extern,
        "extractor" => Token::Extractor,
        "false" => Token::False,
        "if" => Token::If,
        "infallible" => Token::Infallible,
        "let" => Token::Let,
        "partial" => Token::Partial,
        "rule" => Token::Rule,
        "true" => Token::True,
        "type" => Token::Type,

        "ident" => Token::Ident(<String>),
        "integer" => Token::Integer(<i64>),

        "&&" => Token::And,
        "->" => Token::Arrow,
        "=" => Token::Assign,
        ":" => Token::Colon,
        "," => Token::Comma,
        "$" => Token::Dollar,
        "{" => Token::LeftBracket,
        "(" => Token::LeftParen,
        "-" => Token::Minus,
        "}" => Token::RightBracket,
        ")" => Token::RightParen,
        ";" => Token::Semicolon,
        "_" => Token::Underscore,
    }
}

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);

            v
        }
    }
};

pub Definitions: Vec<Definition> = {
    Definition => vec![<>],
    <mut defs:Definitions> <def:Definition> => {
        defs.push(def);

        defs
    }
};

Definition: Definition = {
    // I don't like partial being on decl but I don't know a better place for it
    "decl" <partial:"partial"?> <name: "ident"> "(" <arg_tys: Comma<"ident">> ")" "->" <ret_ty: "ident"> ";" => Definition::Declaration(Declaration {name, arg_tys, ret_ty, partial: partial.is_some()}),
    "type" <name:"ident"> "=" <external_name:"ident"> ";" => Definition::Type(Type {<>}),
    "rule" <priority:"integer"?> <pat:Pattern> <guards:("if" <Guards>)?> "{" <body:Body> "}" => Definition::Rule(Rule {pat, priority, guards: guards.unwrap_or_default(), body}),
    "extern" "constructor" <name:"ident"> "=" <external_name:"ident"> ";" => Definition::Extern(Extern::Constructor {<>}),
    "extern" <infallible:"infallible"?> "extractor" <name:"ident"> "=" <external_name:"ident"> ";" => Definition::Extern(Extern::Extractor {name, external_name, infallible: infallible.is_some()}),
    "extern" "const" <name:Const> ":" <ty:"ident"> ";" => Definition::Extern(Extern::Const {<>}),
}

Guard: Guard = {
    <expr:Expr> => Guard::Expr(<>),
    "let" <pat:Pattern> "=" <expr:Expr> => Guard::Pattern(<>),
}

Guards: Vec<Guard> = {
    <mut v:(<Guard> "&&")*> <e:Guard?> => match e {
        None => v,
        Some(e) => {
            v.push(e);

            v
        }
    }
};

Let: Let = {
    "let" <name:"ident"> ":" <ty:"ident"> "=" <value:Expr> ";" => Let {<>}
}

Body: Body = {
    <lets:Let*> <expr:Expr> => Body {<>}
}

Expr: Expr = {
    <name:"ident"> "(" <args:Comma<Expr>> ")" => Expr::Call {<>},
    Literal => Expr::Literal(<>),
    "ident" => Expr::Ident(<>),
}

Pattern: Pattern = {
    "(" <name:"ident"> <args:Pattern*> ")" => Pattern::Application {<>},
    "_" => Pattern::Wildcard,
    Literal => Pattern::Literal(<>),
    "ident" => Pattern::Ident(<>),
}

Literal: Literal = {
    "-" <"integer"> => Literal::Int(-<>),
    "integer" => Literal::Int(<>),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    Const => Literal::Const(<>),
}

Const = "$" <"ident">;
