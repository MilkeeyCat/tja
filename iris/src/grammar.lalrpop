use crate::ast::{Declaration, Definition, Type, Pattern, Rule, Expr, Literal, Extern, Let, Body};

grammar;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);

            v
        }
    }
};

pub Definitions: Vec<Definition> = {
    Definition => vec![<>],
    <mut defs:Definitions> <def:Definition> => {
        defs.push(def);

        defs
    }
};

Definition: Definition = {
    // I don't like partial being on decl but I don't know a better place for it
    "decl" <partial:"partial"?> <name: Ident> "(" <arg_tys: Comma<Ident>> ")" "->" <ret_ty: Ident> ";" => Definition::Declaration(Declaration {name, arg_tys, ret_ty, partial: partial.is_some()}),
    "type" <name:Ident> "=" <external_name:Ident> ";" => Definition::Type(Type {<>}),
    "rule" <priority:Integer?> <pat:Pattern> "{" <body:Body> "}" => Definition::Rule(Rule{<>}),
    "extern" "constructor" <name:Ident> "=" <external_name:Ident> ";" => Definition::Extern(Extern::Constructor {<>}),
    "extern" <infallible:"infallible"?> "extractor" <name:Ident> "=" <external_name:Ident> ";" => Definition::Extern(Extern::Extractor {name, external_name, infallible: infallible.is_some()}),
    "extern" "const" <name:Const> ":" <ty:Ident> ";" => Definition::Extern(Extern::Const {<>}),
}

Let: Let = {
    "let" <name:Ident> "=" <value:Expr> ";" => Let {<>}
}

Body: Body = {
    <lets:Let*> <expr:Expr> => Body {<>}
}

Expr: Expr = {
    <name:Ident> "(" <args:Comma<Expr>> ")" => Expr::Call {<>},
    Literal => Expr::Literal(<>),
    Ident => Expr::Ident(<>),
}

Pattern: Pattern = {
    "(" <name:Ident> <args:Pattern*> ")" => Pattern::Application {<>},
    "_" => Pattern::Wildcard,
    Literal => Pattern::Literal(<>),
    Ident => Pattern::Ident(<>),
}

Literal: Literal = {
    "-" <Integer> => Literal::Int(-<>),
    Integer => Literal::Int(<>),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
    Const => Literal::Const(<>),
}

Const = "$" <Ident>;

Ident: String = r"[\p{XID_Start}_]\p{XID_Continue}*" => String::from(<>);

Integer: i64 = r"\d+" => <>.parse().unwrap();
